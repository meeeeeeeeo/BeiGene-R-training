<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Base R</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<link rel="stylesheet" href="config/style.css" type="text/css" />
<link rel="stylesheet" href="config/multi-columns.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R training</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="RStudioIDE.html">RStudio IDE</a>
</li>
<li>
  <a href="base_R.html">Base R</a>
</li>
<li>
  <a href="tidyverse-base.html">tidyverse base</a>
</li>
<li>
  <a href="stringr_hs.html">stringr</a>
</li>
<li>
  <a href="datetime_qw.html">date and time</a>
</li>
<li>
  <a href="read-write.html">data import/export</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    ggplot2
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="ggplot2_basic.html">basic</a>
    </li>
    <li>
      <a href="ggplot2_layers.html">layers</a>
    </li>
    <li>
      <a href="arranging-plots.html">arranging plots</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    More
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="pipe.html">Using pipe</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">focusing on package</li>
    <li>
      <a href="data-process-dplyr.html">data process - dplyr</a>
    </li>
    <li>
      <a href="data-process-tidyr.html">data process - tidyr</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Use SQL in R</li>
    <li>
      <a href="sqldf.html">sqldf</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Base R</h1>

</div>


<div id="introduction-to-r" class="section level1">
<h1>1 Introduction to R</h1>
<p>R is a programming language developed by Ross Ihaka and Robert Gentleman in 1993. R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS.</p>
<p>Data analysis with R is done in a series of steps; programming, transforming, discovering, modeling and communicate the results.</p>
<ul>
<li><strong>Program:</strong> R is a clear and accessible programming tool</li>
<li><strong>Transform:</strong> R is made up of a collection of libraries designed specifically for data science</li>
<li><strong>Discover:</strong> Investigate the data, refine your hypothesis and analyze them</li>
<li><strong>Model:</strong> R provides a wide array of tools to capture the right model for your data</li>
<li><strong>Communicate:</strong> Integrate codes, graphs, and outputs to a report with R Markdown or build Shiny apps to share with the world</li>
</ul>
</div>
<div id="objects" class="section level1">
<h1>2 Objects</h1>
<p>The <code>:</code> operator gives you a nice way to create a group of numbers.</p>
<pre class="r"><code>1:6
#&gt; [1] 1 2 3 4 5 6</code></pre>
<p>Running <code>1:6</code> generated a vector of numbers for you to see, but it didn’t save that vector anywhere in your computer’s memory. If you want to use those numbers again, you’ll have to ask your computer to save them somewhere. You can do that by creating an R <em>object</em>.</p>
<p>R lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like <em><code>a</code></em> or <em><code>b</code></em>. Wherever R encounters the object, it will replace it with the data saved inside, like so:</p>
<pre class="r"><code>a &lt;- 1
a
#&gt; [1] 1
a + 2
#&gt; [1] 3</code></pre>
<p>So, for another example, the following code would create an object named <code>die</code> that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:</p>
<pre class="r"><code>die &lt;- 1:6
die
#&gt; [1] 1 2 3 4 5 6</code></pre>
<p>When you create an object, the object will appear in the environment pane of RStudio.</p>
<p>You can name an object in R almost anything you want, but there are a few rules.</p>
<ul>
<li>It should contain letters, numbers, and only dot or underscore characters.</li>
<li>It should not contain use some special symbols, like <code>^</code>, <code>!</code>, <code>$</code>, <code>@</code>, <code>+</code>, <code>-</code>, <code>/</code>, or <code>*</code>.</li>
<li>It should not start with a number (eg: 2iota)</li>
<li>It should not start with a dot followed by a number (eg: .2iota)</li>
<li>It should not start with an underscore (eg: _iota)</li>
<li>It should not be a reserved keyword.</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left">Good names</th>
<th align="left">Names that cause errors</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">a</td>
<td align="left">1trial</td>
</tr>
<tr class="even">
<td align="left">b</td>
<td align="left">$</td>
</tr>
<tr class="odd">
<td align="left">FOO</td>
<td align="left">^mean</td>
</tr>
<tr class="even">
<td align="left">my_var</td>
<td align="left">2nd</td>
</tr>
<tr class="odd">
<td align="left">.day</td>
<td align="left">!bad</td>
</tr>
</tbody>
</table>
<p>But you can skip those rules by using ``.</p>
<pre class="r"><code>`!1` &lt;- 2
`!1`
#&gt; [1] 2</code></pre>
<p>R is case-sensitive, so <code>name</code> and <code>Name</code> will refer to different objects:</p>
<pre class="r"><code>Name &lt;- 1
name &lt;- 0
Name + 1
#&gt; [1] 2</code></pre>
<p>Finally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to <em>not</em> use names that are already taken:</p>
<pre class="r"><code>my_number &lt;- 1
my_number
#&gt; [1] 1
my_number &lt;- 999
my_number
#&gt; [1] 999</code></pre>
<p>The function <code>seq</code> can generate sequences of real numbers as follows:</p>
<pre class="r"><code>seq(5)
#&gt; [1] 1 2 3 4 5
seq(2, 5)
#&gt; [1] 2 3 4 5
seq(1, 5, 0.5)
#&gt; [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0</code></pre>
<p>The function <code>rep</code> creates a vector with all its elements identical:</p>
<pre class="r"><code>rep(1, 5)
#&gt; [1] 1 1 1 1 1
rep(c(1, 3), 3)
#&gt; [1] 1 3 1 3 1 3
rep(c(1, 3), each = 3)
#&gt; [1] 1 1 1 3 3 3
rep(c(1, 3), c(2, 4))
#&gt; [1] 1 1 3 3 3 3</code></pre>
<p>You can see which object names you have already used with the function <code>ls</code>:</p>
<pre class="r"><code>ls()
#&gt;  [1] &quot;!1&quot;        &quot;a&quot;         &quot;die&quot;       &quot;layout&quot;    &quot;my_number&quot; &quot;name&quot;     
#&gt;  [7] &quot;Name&quot;      &quot;p1&quot;        &quot;p12&quot;       &quot;p123&quot;      &quot;p2&quot;        &quot;p24&quot;      
#&gt; [13] &quot;p3&quot;        &quot;p34&quot;       &quot;p4&quot;</code></pre>
<p>You can also see which names you have used by examining RStudio’s environment pane.</p>
<p>To delete objects in memory, we use the function <code>rm</code>:</p>
<pre class="r"><code>rm(die)
ls()
#&gt;  [1] &quot;!1&quot;        &quot;a&quot;         &quot;layout&quot;    &quot;my_number&quot; &quot;name&quot;      &quot;Name&quot;     
#&gt;  [7] &quot;p1&quot;        &quot;p12&quot;       &quot;p123&quot;      &quot;p2&quot;        &quot;p24&quot;       &quot;p3&quot;       
#&gt; [13] &quot;p34&quot;       &quot;p4&quot;</code></pre>
<p>The statement <code>rm(list = ls())</code> will remove all objects from the working environment:</p>
<pre class="r"><code>rm(list = ls())
ls()
#&gt; character(0)</code></pre>
</div>
<div id="vectors" class="section level1">
<h1>3 Vectors</h1>
<div id="vector-basics" class="section level2">
<h2>3.1 Vector Basics</h2>
<p>There are two types of vectors:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Atomic vectors</strong>, of which there are six types: <strong>logical</strong>, <strong>integer</strong>, <strong>double</strong>, <strong>character</strong>, <strong>complex</strong>, and <strong>raw</strong>. Integer and double vectors are collectively known as <strong>numeric</strong> vectors.</p></li>
<li><p><strong>Lists</strong>, which are sometimes called recursive vectors because lists can contain other lists.</p></li>
</ol>
<p>The chief difference between atomic vectors and lists is that atomic vectors are <strong>homogeneous</strong>, while lists can be <strong>heterogeneous</strong>.</p>
<p>There’s one other related object: <code>NULL</code>. <code>NULL</code> is often used to represent the absence of a vector (as opposed to <code>NA</code> which is used to represent the absence of a value in a vector). <code>NULL</code> typically behaves like a vector of length 0.</p>
<div class="figure">
<img src="diagrams/data-structures-overview.png" alt="The hierarchy of R's vector types" width="50%" />
<p class="caption">
The hierarchy of R’s vector types
</p>
</div>
<p>Every vector has two key properties:</p>
<ol style="list-style-type: decimal">
<li>Its <strong>type</strong>, which you can determine with <code>typeof()</code>.</li>
</ol>
<pre class="r"><code>typeof(letters)
#&gt; [1] &quot;character&quot;
typeof(1:10)
#&gt; [1] &quot;integer&quot;</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Its <strong>length</strong>, which you can determine with <code>length()</code>.</li>
</ol>
<pre class="r"><code>x &lt;- list(&quot;a&quot;, &quot;b&quot;, 1:10)
length(x)
#&gt; [1] 3</code></pre>
<p>Vectors can also contain arbitrary additional metadata in the form of attributes. These attributes are used to create <strong>augmented vectors</strong> which build on additional behaviour. There are three important types of augmented vector:</p>
<ul>
<li><strong>Factors</strong> are built on top of integer vectors.</li>
<li><strong>Dates</strong> and <strong>date-times</strong> are built on top of numeric vectors.</li>
<li><strong>Data frames</strong> and <strong>tibbles</strong> are built on top of lists.</li>
</ul>
<p>Further, there are mainly six data types present in R:</p>
<ol style="list-style-type: decimal">
<li><strong>Vectors</strong></li>
<li><strong>Matrices</strong></li>
<li><strong>Arrays</strong></li>
<li><strong>Factors</strong></li>
<li><strong>Lists</strong></li>
<li><strong>DataFrames / tibble</strong></li>
</ol>
<p>We’ll start with the very basics. The most simple type of object in R is an <em>atomic vector</em>. If you look closely enough, you’ll see that most structures in R are built from atomic vectors.</p>
</div>
<div id="atomic-vectors" class="section level2">
<h2>3.2 Atomic Vectors</h2>
<p>An atomic vector is just a simple vector of data. You can make an atomic vector by grouping some values of data together with <code>c</code>:</p>
<pre class="r"><code>die &lt;- c(1, 2, 3, 4, 5, 6)
die
#&gt; [1] 1 2 3 4 5 6
is.vector(die)
#&gt; [1] TRUE</code></pre>
<p><code>is.vector</code> tests whether an object is an atomic vector. It returns <code>TRUE</code> if the object is an atomic vector and <code>FALSE</code> otherwise.</p>
<p>You can also make an atomic vector with just one value. R saves single values as an atomic vector of length 1:</p>
<pre class="r"><code>five &lt;- 5
five
#&gt; [1] 5
is.vector(five)
#&gt; [1] TRUE
length(five)
#&gt; [1] 1
length(die)
#&gt; [1] 6</code></pre>
<p>Each atomic vector stores its values as a one-dimensional vector, and each atomic vector can only store one type of data. You can save different types of data in R by using different types of atomic vectors.</p>
<div id="doubles" class="section level3">
<h3>3.2.1 Doubles</h3>
<p>A double vector stores regular numbers. The numbers can be positive or negative, large or small, and have digits to the right of the decimal place or not. In general, R will save any number that you type in R as a double.</p>
<pre class="r"><code>die &lt;- c(1, 2, 3, 4, 5, 6)
die
#&gt; [1] 1 2 3 4 5 6
typeof(die)
#&gt; [1] &quot;double&quot;</code></pre>
<p>Some R functions refer to doubles as “numerics”.</p>
</div>
<div id="integers" class="section level3">
<h3>3.2.2 Integers</h3>
<p>Integer vectors store integers, numbers that can be written without a decimal component.</p>
<p>You can specifically create an integer in R by typing a number followed by an uppercase <code>L</code>. For example:</p>
<pre class="r"><code>int &lt;- c(-1L, 2L, 4L)
int
#&gt; [1] -1  2  4
typeof(int)
#&gt; [1] &quot;integer&quot;</code></pre>
<p>Note that R won’t save a number as an integer unless you include the <code>L</code>. Integer numbers without the <code>L</code> will be saved as doubles. The only difference between <code>4</code> and <code>4L</code> is how R saves the number in your computer’s memory. Integers are defined more precisely in your computer’s memory than doubles (unless the integer is <em>very</em> large or small).</p>
<p>Sometimes a difference in precision can have surprising effects. Your computer allocates 64 bits of memory to store each double in an R program. As a result, each double is accurate to about 16 significant digits. This introduces a little bit of error. For example, you may expect the result of the expression below to be zero, but it is not:</p>
<pre class="r"><code>sqrt(2)^2
#&gt; [1] 2
sqrt(2)^2 - 2
#&gt; [1] 4.440892e-16
dplyr::near(sqrt(2)^2, 2)
#&gt; [1] TRUE</code></pre>
<p>These errors are known as <em>floating-point</em> errors, and doing arithmetic in these conditions is known as <em>floating-point arithmetic</em>. Floating-point arithmetic is not a feature of R; it is a feature of computer programming. Luckily, the errors caused by floating-point arithmetic are usually insignificant (and when they are not, they are easy to spot). As a result, you’ll generally use doubles instead of integers as a data scientist.</p>
</div>
<div id="characters" class="section level3">
<h3>3.2.3 Characters</h3>
<p>A character vector stores small pieces of text. You can create a character vector in R by typing a character or string of characters surrounded by quotes:</p>
<pre class="r"><code>text &lt;- c(&quot;Hello&quot;,  &quot;World!&quot;)
text
#&gt; [1] &quot;Hello&quot;  &quot;World!&quot;
typeof(text)
#&gt; [1] &quot;character&quot;
typeof(&quot;Hello&quot;)
#&gt; [1] &quot;character&quot;</code></pre>
<p>The individual elements of a character vector are known as <em>strings</em>. Note that a string can contain more than just letters. You can assemble a character string from numbers or symbols as well. In fact, anything surrounded by quotes in R will be treated as a character string—no matter what appears between the quotes.</p>
<p>We can use the function <code>paste</code> and <code>paste0</code> joins multiple vectors together.</p>
<pre class="r"><code>paste(&quot;Hello&quot;, &quot;World!&quot;, sep = &quot; &quot;)
#&gt; [1] &quot;Hello World!&quot;
paste(&quot;x&quot;, 1:3, sep = &quot;_&quot;)
#&gt; [1] &quot;x_1&quot; &quot;x_2&quot; &quot;x_3&quot;
paste(text, collapse = &quot; &quot;)
#&gt; [1] &quot;Hello World!&quot;
paste0(&quot;Today is &quot;, date())
#&gt; [1] &quot;Today is Mon Oct 25 20:52:33 2021&quot;</code></pre>
</div>
<div id="logicals" class="section level3">
<h3>3.2.4 Logicals</h3>
<p>Logical vectors store <code>TRUE</code>s and <code>FALSE</code>s, R’s form of Boolean data. Logicals are very helpful for doing things like comparisons:</p>
<pre class="r"><code>3 &gt; 4
#&gt; [1] FALSE</code></pre>
<p>Any time you type <code>TRUE</code> or <code>FALSE</code> in capital letters (without quotation marks), R will treat your input as logical data. R also assumes that <code>T</code> and <code>F</code> are shorthand for <code>TRUE</code> and <code>FALSE</code>, unless they are defined elsewhere (e.g. <code>T &lt;- 500</code>). Since the meaning of <code>T</code> and <code>F</code> can change, its best to stick with <code>TRUE</code> and <code>FALSE</code>:</p>
<pre class="r"><code>logic &lt;- c(TRUE, FALSE, TRUE)
logic
#&gt; [1]  TRUE FALSE  TRUE
typeof(logic)
#&gt; [1] &quot;logical&quot;
typeof(F)
#&gt; [1] &quot;logical&quot;
F &lt;- 500
typeof(F)
#&gt; [1] &quot;double&quot;</code></pre>
</div>
<div id="complex-and-raw" class="section level3">
<h3>3.2.5 Complex and Raw</h3>
<p>Doubles, integers, characters, and logicals are the most common types of atomic vectors in R, but R also recognizes two more types: complex and raw.</p>
<p>Complex vectors store complex numbers. To create a complex vector, add an imaginary term to a number with <code>i</code>:</p>
<pre class="r"><code>comp &lt;- c(1 + 1i, 1 + 2i, 1 + 3i)
comp
#&gt; [1] 1+1i 1+2i 1+3i
typeof(comp)
#&gt; [1] &quot;complex&quot;</code></pre>
<p>Raw vectors store raw bytes of data. Making raw vectors gets complicated, but you can make an empty raw vector of length <em>n</em> with <code>raw(n)</code>. See the help page of <code>raw</code> for more options when working with this type of data:</p>
<pre class="r"><code>raw(3)
#&gt; [1] 00 00 00
typeof(raw(3))
#&gt; [1] &quot;raw&quot;</code></pre>
</div>
</div>
<div id="attributes" class="section level2">
<h2>3.3 Attributes</h2>
<p>An attribute is a piece of information that you can attach to an atomic vector (or any R object). The attribute won’t affect any of the values in the object, and it will not appear when you display your object. You can think of an attribute as “metadata”; it is just a convenient place to put information associated with an object. R will normally ignore this metadata, but some R functions will check for specific attributes. These functions may use the attributes to do special things with the data.</p>
<p>You can see which attributes an object has with <code>attributes</code>. <code>attributes</code> will return <code>NULL</code> if an object has no attributes. An atomic vector, like <code>die</code>, won’t have any attributes unless you give it some:</p>
<pre class="r"><code>attributes(die)
#&gt; NULL</code></pre>
<p>R uses <code>NULL</code> to represent the null set, an empty object. <code>NULL</code> is often returned by functions whose values are undefined. You can create a <code>NULL</code> object by typing <code>NULL</code> in capital letters.</p>
<div id="names" class="section level3">
<h3>3.3.1 Names</h3>
<p>The most common attributes to give an atomic vector are names, dimensions (dim), and classes. Each of these attributes has its own helper function that you can use to give attributes to an object. You can also use the helper functions to look up the value of these attributes for objects that already have them. For example, you can look up the value of the names attribute of <code>die</code> with <code>names</code>:</p>
<pre class="r"><code>names(die)
#&gt; NULL</code></pre>
<p><code>NULL</code> means that <code>die</code> does not have a names attribute. You can give one to <code>die</code> by assigning a character vector to the output of <code>names</code>. The vector should include one name for each element in <code>die</code>:</p>
<pre class="r"><code>names(die) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)</code></pre>
<p>Now <code>die</code> has a names attribute:</p>
<pre class="r"><code>names(die)
#&gt; [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot; &quot;four&quot;  &quot;five&quot;  &quot;six&quot;
attributes(die)
#&gt; $names
#&gt; [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot; &quot;four&quot;  &quot;five&quot;  &quot;six&quot;</code></pre>
<p>R will display the names above the elements of <code>die</code> whenever you look at the vector:</p>
<pre class="r"><code>die
#&gt;   one   two three  four  five   six 
#&gt;     1     2     3     4     5     6</code></pre>
<p>However, the names won’t affect the actual values of the vector, nor will the names be affected when you manipulate the values of the vector:</p>
<pre class="r"><code>die + 1
#&gt;   one   two three  four  five   six 
#&gt;     2     3     4     5     6     7</code></pre>
<p>You can also use <code>names</code> to change the names attribute or remove it all together. To change the names, assign a new set of labels to <code>names</code>:</p>
<pre class="r"><code>names(die) &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;quatro&quot;, &quot;cinco&quot;, &quot;seis&quot;)
die
#&gt;    uno    dos   tres quatro  cinco   seis 
#&gt;      1      2      3      4      5      6</code></pre>
<p>To remove the names attribute, set it to <code>NULL</code>:</p>
<pre class="r"><code>names(die) &lt;- NULL
die
#&gt; [1] 1 2 3 4 5 6</code></pre>
</div>
<div id="dim" class="section level3">
<h3>3.3.2 Dim</h3>
<p>You can transform an atomic vector into an <em>n</em>-dimensional array by giving it a dimensions attribute with <code>dim</code>. To do this, set the <code>dim</code> attribute to a numeric vector of length <em>n</em>. R will reorganize the elements of the vector into <em>n</em> dimensions. Each dimension will have as many rows (or columns, etc.) as the <em>nth</em> value of the <code>dim</code> vector. For example, you can reorganize <code>die</code> into a 2 × 3 matrix (which has 2 rows and 3 columns):</p>
<pre class="r"><code>dim(die) &lt;- c(2, 3)
die
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    3    5
#&gt; [2,]    2    4    6</code></pre>
<p>or a 3 × 2 matrix (which has 3 rows and 2 columns):</p>
<pre class="r"><code>dim(die) &lt;- c(3, 2)
die
#&gt;      [,1] [,2]
#&gt; [1,]    1    4
#&gt; [2,]    2    5
#&gt; [3,]    3    6</code></pre>
<p>or a 1 × 2 × 3 hypercube (which has 1 row, 2 columns, and 3 “slices”). This is a three-dimensional structure, but R will need to show it slice by slice by slice on your two-dimensional computer screen:</p>
<pre class="r"><code>dim(die) &lt;- c(1, 2, 3)
die
#&gt; , , 1
#&gt; 
#&gt;      [,1] [,2]
#&gt; [1,]    1    2
#&gt; 
#&gt; , , 2
#&gt; 
#&gt;      [,1] [,2]
#&gt; [1,]    3    4
#&gt; 
#&gt; , , 3
#&gt; 
#&gt;      [,1] [,2]
#&gt; [1,]    5    6</code></pre>
<p>R will always use the first value in <code>dim</code> for the number of rows and the second value for the number of columns. In general, rows always come first in R operations that deal with both rows and columns.</p>
<p>You may notice that you don’t have much control over how R reorganizes the values into rows and columns. For example, R always fills up each matrix by columns, instead of by rows. If you’d like more control over this process, you can use one of R’s helper functions, <code>matrix</code> or <code>array</code>. They do the same thing as changing the <code>dim</code> attribute, but they provide extra arguments to customize the process.</p>
</div>
</div>
<div id="matrices" class="section level2">
<h2>3.4 Matrices</h2>
<p>Matrices store values in a two-dimensional array, just like a matrix from linear algebra. To create one, first give <code>matrix</code> an atomic vector to reorganize into a matrix. Then, define how many rows should be in the matrix by setting the <code>nrow</code> argument to a number. <code>matrix</code> will organize your vector of values into a matrix with the specified number of rows. Alternatively, you can set the <code>ncol</code> argument, which tells R how many columns to include in the matrix:</p>
<pre class="r"><code>m &lt;- matrix(die, nrow = 2)
m
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    3    5
#&gt; [2,]    2    4    6</code></pre>
<p><code>matrix</code> will fill up the matrix column by column by default, but you can fill the matrix row by row if you include the argument <code>byrow = TRUE</code>:</p>
<pre class="r"><code>m &lt;- matrix(die, nrow = 2, byrow = TRUE)
m
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    2    3
#&gt; [2,]    4    5    6</code></pre>
<p>You can use <code>nrow</code> and <code>ncol</code> to access the number of rows and columns of the matrix:</p>
<pre class="r"><code>nrow(m)
#&gt; [1] 2
ncol(m)
#&gt; [1] 3</code></pre>
<p>The matrix has a dim attribute that contains a vector of two elements, the number of rows and columns of the matrix.The dim property can be accessed using the <code>dim</code>:</p>
<pre class="r"><code>attributes(m)
#&gt; $dim
#&gt; [1] 2 3
dim(m)
#&gt; [1] 2 3</code></pre>
</div>
<div id="arrays" class="section level2">
<h2>3.5 Arrays</h2>
<p>The <code>array</code> function creates an n-dimensional array. For example, you could use <code>array</code> to sort values into a cube of three dimensions or a hypercube in 4, 5, or <em>n</em> dimensions. <code>array</code> is not as customizeable as <code>matrix</code> and basically does the same thing as setting the <code>dim</code> attribute. To use <code>array</code>, provide an atomic vector as the first argument, and a vector of dimensions as the second argument, now called <code>dim</code>:</p>
<pre class="r"><code>ar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))
ar
#&gt; , , 1
#&gt; 
#&gt;      [,1] [,2]
#&gt; [1,]   11   13
#&gt; [2,]   12   14
#&gt; 
#&gt; , , 2
#&gt; 
#&gt;      [,1] [,2]
#&gt; [1,]   21   23
#&gt; [2,]   22   24
#&gt; 
#&gt; , , 3
#&gt; 
#&gt;      [,1] [,2]
#&gt; [1,]   31   33
#&gt; [2,]   32   34</code></pre>
</div>
<div id="class" class="section level2">
<h2>3.6 Class</h2>
<p>Notice that changing the dimensions of your object will not change the type of the object, but it <em>will</em> change the object’s <code>class</code> attribute:</p>
<pre class="r"><code>dim(die) &lt;- c(2, 3)
typeof(die)
#&gt; [1] &quot;double&quot;
class(die)
#&gt; [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<p>A matrix is a special case of an atomic vector. For example, the <code>die</code> matrix is a special case of a double vector. Every element in the matrix is still a double, but the elements have been arranged into a new structure. R added a <code>class</code> attribute to <code>die</code> when you changed its dimensions. This class describes <code>die</code>’s new format. Many R functions will specifically look for an object’s <code>class</code> attribute, and then handle the object in a predetermined way based on the attribute.</p>
<p>Note that an object’s <code>class</code> attribute will not always appear when you run <code>attributes</code>; you may need to specifically search for it with <code>class</code>:</p>
<pre class="r"><code>attributes(die)
#&gt; $dim
#&gt; [1] 2 3</code></pre>
<p>You can apply <code>class</code> to objects that do not have a <code>class</code> attribute. <code>class</code> will return a value based on the object’s atomic type. Notice that the “class” of a double is “numeric”:</p>
<pre class="r"><code>class(&quot;Hello&quot;)
#&gt; [1] &quot;character&quot;
class(5)
#&gt; [1] &quot;numeric&quot;</code></pre>
<div id="dates-and-times" class="section level3">
<h3>3.6.1 Dates and Times</h3>
<p>Dates in R are numeric vectors that represent the number of days since 1 January 1970.</p>
<pre class="r"><code>today &lt;- Sys.Date()
today
#&gt; [1] &quot;2021-10-25&quot;
typeof(today)
#&gt; [1] &quot;double&quot;
class(today)
#&gt; [1] &quot;Date&quot;
unclass(today)
#&gt; [1] 18925</code></pre>
<p>Date-times are numeric vectors with class <code>POSIXct</code> that represent the number of seconds since 12:00 AM January 1st 1970 (in the Universal Time Coordinated (UTC) zone). (In case you were wondering, “POSIXct” stands for “Portable Operating System Interface”, calendar time.)</p>
<pre class="r"><code>now &lt;- Sys.time()
now
#&gt; [1] &quot;2021-10-25 20:52:33 PDT&quot;
typeof(now)
#&gt; [1] &quot;double&quot;
class(now)
#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot;
unclass(now)
#&gt; [1] 1635220353
Sys.timezone()
#&gt; [1] &quot;America/Los_Angeles&quot;
lubridate::with_tz(now, tzone = &quot;Asia/Shanghai&quot;)
#&gt; [1] &quot;2021-10-26 11:52:33 CST&quot;</code></pre>
</div>
<div id="factors" class="section level3">
<h3>3.6.2 Factors</h3>
<p>Factors are R’s way of storing categorical information, like ethnicity or eye color. To make a factor, pass an atomic vector into the <code>factor</code> function. R will recode the data in the vector as integers and store the results in an integer vector. R will also add a <code>levels</code> attribute to the integer, which contains a set of labels for displaying the factor values, and a <code>class</code> attribute, which contains the class <code>factor</code>:</p>
<pre class="r"><code>gender &lt;- factor(c(&quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;))
gender
#&gt; [1] male   female female male  
#&gt; Levels: female male
typeof(gender)
#&gt; [1] &quot;integer&quot;
attributes(gender)
#&gt; $levels
#&gt; [1] &quot;female&quot; &quot;male&quot;  
#&gt; 
#&gt; $class
#&gt; [1] &quot;factor&quot;</code></pre>
<p>You can see exactly how R is storing your factor with <code>unclass</code>:</p>
<pre class="r"><code>unclass(gender)
#&gt; [1] 2 1 1 2
#&gt; attr(,&quot;levels&quot;)
#&gt; [1] &quot;female&quot; &quot;male&quot;</code></pre>
<p>Factors make it easy to put categorical variables into a statistical model because the variables are already coded as numbers. However, factors can be confusing since they look like character strings but behave like integers.</p>
<p>R will often try to convert character strings to factors when you load and create data. You can convert a factor to a character string with the <code>as.character</code> function. R will retain the display version of the factor, not the integers stored in memory:</p>
<pre class="r"><code>as.character(gender)
#&gt; [1] &quot;male&quot;   &quot;female&quot; &quot;female&quot; &quot;male&quot;</code></pre>
</div>
</div>
<div id="using-atomic-vectors" class="section level2">
<h2>3.7 Using Atomic Vectors</h2>
<p>Now that you understand the different types of atomic vector, it’s useful to review some of the important tools for working with them. These include:</p>
<ol style="list-style-type: decimal">
<li><p>How to convert from one type to another, and when that happens automatically.</p></li>
<li><p>How to tell if an object is a specific type of vector.</p></li>
<li><p>What happens when you work with vectors of different lengths.</p></li>
<li><p>How to pull out elements of interest.</p></li>
<li><p>How to merge the elements of vectors.</p></li>
</ol>
<div id="coercion" class="section level3">
<h3>3.7.1 Coercion</h3>
<p>If you try to put multiple types of data into a vector, R will convert the elements to a single type of data.R’s coercion behavior may seem inconvenient, but it is not arbitrary. R always follows the same rules when it coerces data types. Once you are familiar with these rules, you can use R’s coercion behavior to do surprisingly useful things.</p>
<p>So how does R coerce data types? If a character string is present in an atomic vector, R will convert everything else in the vector to character strings. If a vector only contains logicals and numbers, R will convert the logicals to numbers; every <code>TRUE</code> becomes a 1, and every <code>FALSE</code> becomes a 0.</p>
<div class="figure">
<img src="images/hopr_0301.png" alt="R always uses the same rules to coerce data to a single type." width="50%" />
<p class="caption">
R always uses the same rules to coerce data to a single type.
</p>
</div>
<p>R uses the same coercion rules when you try to do math with logical values. So the following code:</p>
<pre class="r"><code>sum(c(TRUE, TRUE, FALSE, FALSE))
#&gt; [1] 2</code></pre>
<p>will become:</p>
<pre class="r"><code>sum(c(1, 1, 0, 0))
#&gt; [1] 2</code></pre>
<p>You can explicitly ask R to convert data from one type to another with the <code>as</code> functions. R will convert the data whenever there is a sensible way to do so:</p>
<pre class="r"><code>as.character(1)
#&gt; [1] &quot;1&quot;
as.logical(1)
#&gt; [1] TRUE
as.numeric(FALSE)
#&gt; [1] 0</code></pre>
<p>In some cases, using only a single type of data is a huge advantage. Vectors, matrices, and arrays make it very easy to do math on large sets of numbers because R knows that it can manipulate each value the same way. Operations with vectors, matrices, and arrays also tend to be fast because the objects are so simple to store in memory.</p>
</div>
<div id="test-functions" class="section level3">
<h3>3.7.2 Test Functions</h3>
<p>Sometimes you want to do different things based on the type of vector. One option is to use <code>typeof()</code>. Another is to use a test function which returns a <code>TRUE</code> or <code>FALSE</code>. Base R provides many functions like <code>is.vector()</code> and <code>is.atomic()</code>, but they often return surprising results. Instead, it’s safer to use the <code>is_*</code> functions provided by purrr, which are summarised in the table below.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">logical</th>
<th align="left">integer</th>
<th align="left">double</th>
<th align="left">character</th>
<th align="left">list</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>is_logical()</code></td>
<td align="left">x</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>is_integer()</code></td>
<td align="left"></td>
<td align="left">x</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>is_double()</code></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">x</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>is_numeric()</code></td>
<td align="left"></td>
<td align="left">x</td>
<td align="left">x</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>is_character()</code></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">x</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>is_atomic()</code></td>
<td align="left">x</td>
<td align="left">x</td>
<td align="left">x</td>
<td align="left">x</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>is_list()</code></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">x</td>
</tr>
<tr class="even">
<td align="left"><code>is_vector()</code></td>
<td align="left">x</td>
<td align="left">x</td>
<td align="left">x</td>
<td align="left">x</td>
<td align="left">x</td>
</tr>
</tbody>
</table>
</div>
<div id="scalars-and-recycling-rules" class="section level3">
<h3>3.7.3 Scalars and Recycling Rules</h3>
<p>As well as implicitly coercing the types of vectors to be compatible, R will also implicitly coerce the length of vectors. This is called vector <strong>recycling</strong>, because the shorter vector is repeated, or recycled, to the same length as the longer vector.</p>
<p>This is generally most useful when you are mixing vectors and “scalars”. I put scalars in quotes because R doesn’t actually have scalars: instead, a single number is a vector of length 1. Because there are no scalars, most built-in functions are <strong>vectorised</strong>, meaning that they will operate on a vector of numbers. That’s why, for example, this code works:</p>
<pre class="r"><code>sample(10) + 100
#&gt;  [1] 106 108 105 109 103 110 104 102 107 101
runif(10) &gt; 0.5
#&gt;  [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE</code></pre>
<p>In R, basic mathematical operations work with vectors. That means that you should never need to perform explicit iteration when performing simple mathematical computations.</p>
<p>It’s intuitive what should happen if you add two vectors of the same length, or a vector and a “scalar”, but what happens if you add two vectors of different lengths?</p>
<pre class="r"><code>1:10 + 1:2
#&gt;  [1]  2  4  4  6  6  8  8 10 10 12</code></pre>
<p>Here, R will expand the shortest vector to the same length as the longest, so called recycling. This is silent except when the length of the longer is not an integer multiple of the length of the shorter:</p>
<pre class="r"><code>1:10 + 1:3
#&gt; Warning in 1:10 + 1:3: longer object length is not a multiple of shorter object
#&gt; length
#&gt;  [1]  2  4  6  5  7  9  8 10 12 11</code></pre>
<p>While vector recycling can be used to create very succinct, clever code, it can also silently conceal problems.</p>
</div>
<div id="subsetting" class="section level3">
<h3>3.7.4 Subsetting</h3>
<p><code>[</code> is the subsetting function, and is called like <code>x[a]</code>. There are four types of things that you can subset a vector with:</p>
<ol style="list-style-type: decimal">
<li><p>A numeric vector containing only integers. The integers must either be all positive, all negative, or zero.</p>
<p>Subsetting with positive integers keeps the elements at those positions:</p>
<pre class="r"><code>x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)
x[c(3, 2, 5)]
#&gt; [1] &quot;three&quot; &quot;two&quot;   &quot;five&quot;</code></pre>
<p>By repeating a position, you can actually make a longer output than input:</p>
<pre class="r"><code>x[c(1, 1, 5, 5, 5, 2)]
#&gt; [1] &quot;one&quot;  &quot;one&quot;  &quot;five&quot; &quot;five&quot; &quot;five&quot; &quot;two&quot;</code></pre>
<p>Negative values drop the elements at the specified positions:</p>
<pre class="r"><code>x[c(-1, -3, -5)]
#&gt; [1] &quot;two&quot;  &quot;four&quot;</code></pre>
<p>It’s an error to mix positive and negative values:</p>
<pre class="r"><code>x[c(1, -1)]
#&gt; Error in x[c(1, -1)]: only 0&#39;s may be mixed with negative subscripts</code></pre>
<p>The error message mentions subsetting with zero, which returns no values:</p>
<pre class="r"><code>x[0]
#&gt; character(0)</code></pre>
<p>This is not useful very often, but it can be helpful if you want to create unusual data structures to test your functions with.</p></li>
<li><p>Subsetting with a logical vector keeps all values corresponding to a <code>TRUE</code> value. This is most often useful in conjunction with the comparison functions.</p>
<pre class="r"><code>x &lt;- c(10, 3, NA, 5, 8, 1, NA)
# All non-missing values of x
x[!is.na(x)]
#&gt; [1] 10  3  5  8  1
# All even (or missing!) values of x
x[x %% 2 == 0]
#&gt; [1] 10 NA  8 NA
x[!is.na(x) &amp; x %% 2 == 0]
#&gt; [1] 10  8</code></pre></li>
<li><p>If you have a named vector, you can subset it with a character vector:</p>
<pre class="r"><code>x &lt;- c(abc = 1, def = 2, xyz = 5)
x[c(&quot;xyz&quot;, &quot;def&quot;)]
#&gt; xyz def 
#&gt;   5   2</code></pre>
<p>Like with positive integers, you can also use a character vector to duplicate individual entries.</p></li>
<li><p>The simplest type of subsetting is nothing, <code>x[]</code>, which returns the complete <code>x</code>. This is not useful for subsetting vectors, but it is useful when subsetting matrices (and other high dimensional structures) because it lets you select all the rows or all the columns, by leaving that index blank.</p>
<pre class="r"><code>m &lt;- matrix(1:6, nrow = 2)
m
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    3    5
#&gt; [2,]    2    4    6
m[1, ]
#&gt; [1] 1 3 5
m[ ,-1]
#&gt;      [,1] [,2]
#&gt; [1,]    3    5
#&gt; [2,]    4    6</code></pre>
<p>Notice that when you take a subset of a matrix, if you take a subset that has only one row or only one column, you’re no longer going to be a matrix but you’re going to be an R vector, which is neither a row vector nor a column vector.To prevent this rule from working, add the <code>drop = FALSE</code> option to the square bracket subscript.</p>
<pre class="r"><code>m1 &lt;- m[ , 1]
m1
#&gt; [1] 1 2
attributes(m1)
#&gt; NULL
m2 &lt;- m[ , 1, drop = FALSE]
m2
#&gt;      [,1]
#&gt; [1,]    1
#&gt; [2,]    2
attributes(m2)
#&gt; $dim
#&gt; [1] 2 1</code></pre></li>
</ol>
</div>
<div id="merging" class="section level3">
<h3>3.7.5 Merging</h3>
<p>If <code>x</code> is a vector, <code>cbind(x)</code> turns x into a column vector, that is, a matrix with columns of 1, and <code>rbind(x)</code> turns x into a row vector.</p>
<p>If <code>x1</code>, <code>x2</code>, <code>x3</code> are equal length vectors, <code>cbind(x1, x2, x3)</code> treats them as column vectors and puts them together to form a matrix.The arguments of <code>cbind</code> can contain both a vector and a matrix, and the length of the vector must be equal to the number of rows in the matrix.</p>
<pre class="r"><code>c1 &lt;- cbind(c(1,2,3))
c1
#&gt;      [,1]
#&gt; [1,]    1
#&gt; [2,]    2
#&gt; [3,]    3
cbind(c(1,2), c(3,4), c(5,6))
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    3    5
#&gt; [2,]    2    4    6
c2 &lt;- matrix(1:6, nrow = 3)
c2
#&gt;      [,1] [,2]
#&gt; [1,]    1    4
#&gt; [2,]    2    5
#&gt; [3,]    3    6
cbind(c2, c(1,-1,10))
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    4    1
#&gt; [2,]    2    5   -1
#&gt; [3,]    3    6   10</code></pre>
<p><code>cbind</code> is also allowed to have scalars in its arguments, where the scalars are reused</p>
<pre class="r"><code>cbind(1, c(1,-1,10))
#&gt;      [,1] [,2]
#&gt; [1,]    1    1
#&gt; [2,]    1   -1
#&gt; [3,]    1   10
cbind(c(1,2), c(1,-1,10))
#&gt; Warning in cbind(c(1, 2), c(1, -1, 10)): number of rows of result is not a
#&gt; multiple of vector length (arg 1)
#&gt;      [,1] [,2]
#&gt; [1,]    1    1
#&gt; [2,]    2   -1
#&gt; [3,]    1   10</code></pre>
<p><code>rbind</code> is used in a similar way. You can put a vector of equal length together as a row vector, or a matrix together with a vector of length equal to the number of columns in the matrix, or a vector of length one.</p>
<pre class="r"><code>r1 &lt;- rbind(c(1,2,3))
r1
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    2    3
rbind(c(1,2), c(3,4), c(5,6))
#&gt;      [,1] [,2]
#&gt; [1,]    1    2
#&gt; [2,]    3    4
#&gt; [3,]    5    6
r2 &lt;- matrix(1:6, ncol = 3)
r2
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    3    5
#&gt; [2,]    2    4    6
rbind(r2, c(1,-1,10))
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    3    5
#&gt; [2,]    2    4    6
#&gt; [3,]    1   -1   10
rbind(1, c(1,-1,10))
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    1    1
#&gt; [2,]    1   -1   10
rbind(c(1,2), c(1,-1,10))
#&gt; Warning in rbind(c(1, 2), c(1, -1, 10)): number of columns of result is not a
#&gt; multiple of vector length (arg 1)
#&gt;      [,1] [,2] [,3]
#&gt; [1,]    1    2    1
#&gt; [2,]    1   -1   10</code></pre>
</div>
</div>
<div id="lists" class="section level2">
<h2>3.8 Lists</h2>
<p>Lists are like atomic vectors because they group data into a one-dimensional set. However, lists do not group together individual values; lists group together R objects, such as atomic vectors and other lists. For example, you can make a list that contains a numeric vector of length 31 in its first element, a character vector of length 1 in its second element, and a new list of length 2 in its third element. To do this, use the <code>list</code> function.</p>
<p><code>list</code> creates a list the same way <code>c</code> creates a vector. Separate each element in the list with a comma:</p>
<pre class="r"><code>list1 &lt;- list(100:130, &quot;R&quot;, list(TRUE, FALSE))
list1
#&gt; [[1]]
#&gt;  [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118
#&gt; [20] 119 120 121 122 123 124 125 126 127 128 129 130
#&gt; 
#&gt; [[2]]
#&gt; [1] &quot;R&quot;
#&gt; 
#&gt; [[3]]
#&gt; [[3]][[1]]
#&gt; [1] TRUE
#&gt; 
#&gt; [[3]][[2]]
#&gt; [1] FALSE</code></pre>
<p>Lists are a basic type of object in R, on par with atomic vectors. Like atomic vectors, they are used as building blocks to create many more spohisticated types of R objects.</p>
<p>As you can imagine, the structure of lists can become quite complicated, but this flexibility makes lists a useful all-purpose storage tool in R: you can group together anything with a list.</p>
<p>A very useful tool for working with lists is <code>str()</code> because it focusses on the <strong>structure</strong>, not the contents.</p>
<pre class="r"><code>str(list1)
#&gt; List of 3
#&gt;  $ : int [1:31] 100 101 102 103 104 105 106 107 108 109 ...
#&gt;  $ : chr &quot;R&quot;
#&gt;  $ :List of 2
#&gt;   ..$ : logi TRUE
#&gt;   ..$ : logi FALSE</code></pre>
<div id="subsetting-1" class="section level3">
<h3>3.8.1 Subsetting</h3>
<p>There are three ways to subset a list, which I’ll illustrate with a list named <code>a</code>:</p>
<pre class="r"><code>a &lt;- list(a = 1:3, b = &quot;a string&quot;, c = pi, d = list(-1, -5))
str(a)
#&gt; List of 4
#&gt;  $ a: int [1:3] 1 2 3
#&gt;  $ b: chr &quot;a string&quot;
#&gt;  $ c: num 3.14
#&gt;  $ d:List of 2
#&gt;   ..$ : num -1
#&gt;   ..$ : num -5</code></pre>
<ol style="list-style-type: decimal">
<li><p><code>[</code> extracts a sub-list. The result will always be a list.</p>
<pre class="r"><code>str(a[1:2])
#&gt; List of 2
#&gt;  $ a: int [1:3] 1 2 3
#&gt;  $ b: chr &quot;a string&quot;
str(a[4])
#&gt; List of 1
#&gt;  $ d:List of 2
#&gt;   ..$ : num -1
#&gt;   ..$ : num -5</code></pre>
<p>Like with vectors, you can subset with a logical, integer, or character vector.</p></li>
<li><p><code>[[</code> extracts a single component from a list. It removes a level of hierarchy from the list.</p>
<pre class="r"><code>str(a[[1]])
#&gt;  int [1:3] 1 2 3
str(a[[4]])
#&gt; List of 2
#&gt;  $ : num -1
#&gt;  $ : num -5</code></pre></li>
<li><p><code>$</code> is a shorthand for extracting named elements of a list. It works similarly to <code>[[</code> except that you don’t need to use quotes.</p>
<pre class="r"><code>a$a
#&gt; [1] 1 2 3
a[[&quot;a&quot;]]
#&gt; [1] 1 2 3</code></pre></li>
</ol>
<p>The distinction between <code>[</code> and <code>[[</code> is really important for lists, because <code>[[</code> drills down into the list while <code>[</code> returns a new, smaller list.</p>
<div class="figure">
<img src="diagrams/lists-subsetting.png" alt="Subsetting a list, visually." width="40%" />
<p class="caption">
Subsetting a list, visually.
</p>
</div>
</div>
</div>
<div id="data-frames" class="section level2">
<h2>3.9 Data Frames</h2>
<p>Data frames are the two-dimensional version of a list. They are far and away the most useful storage structure for data analysis. You can think of a data frame as R’s equivalent to the Excel spreadsheet because it stores data in a similar format.</p>
<p>Data frames group vectors together into a two-dimensional table. Each vector becomes a column in the table. As a result, each column of a data frame can contain a different type of data; but within a column, every cell must be the same type of data.</p>
<p>Creating a data frame by hand takes a lot of typing, but you can do it (if you like) with the <code>data.frame</code> function. Give <code>data.frame</code> any number of vectors, each separated with a comma. Each vector should be set equal to a name that describes the vector. <code>data.frame</code> will turn each vector into a column of the new data frame:</p>
<pre class="r"><code>df &lt;- data.frame(face = c(&quot;ace&quot;, &quot;two&quot;, &quot;six&quot;), suit = c(&quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;), value = c(1, 2, 3), stringsAsFactors = TRUE)
df
#&gt;   face  suit value
#&gt; 1  ace clubs     1
#&gt; 2  two clubs     2
#&gt; 3  six clubs     3</code></pre>
<p>You’ll need to make sure that each vector is the same length (or can be made so with R’s recycling rules), as data frames cannot combine columns of different lengths.</p>
<p>If you look at the type of a data frame, you will see that it is a list. In fact, each data frame is a list with class <code>data.frame</code>. You can see what types of objects are grouped together by a list (or data frame) with the <code>str</code> function:</p>
<pre class="r"><code>typeof(df)
#&gt; [1] &quot;list&quot;
class(df)
#&gt; [1] &quot;data.frame&quot;
str(df)
#&gt; &#39;data.frame&#39;:    3 obs. of  3 variables:
#&gt;  $ face : Factor w/ 3 levels &quot;ace&quot;,&quot;six&quot;,&quot;two&quot;: 1 3 2
#&gt;  $ suit : Factor w/ 1 level &quot;clubs&quot;: 1 1 1
#&gt;  $ value: num  1 2 3</code></pre>
<p>Notice that R saved your character strings as factors. It is not a very big deal here, but you can prevent this behavior by adding the argument <code>stringsAsFactors = FALSE</code> to <code>data.frame</code>:</p>
<p><strong>Note:</strong> <code>StringsAsFactors</code> determines should character vectors be converted to factors. The ‘factory-fresh’ default has been TRUE previously but has been changed to FALSE for R 4.0.0. Only as short time workaround, you can revert by setting options(stringsAsFactors = TRUE) which now warns about its deprecation.</p>
<pre class="r"><code>df1 &lt;- data.frame(face = c(&quot;ace&quot;, &quot;two&quot;, &quot;six&quot;), suit = c(&quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;), value = c(1, 2, 3))
str(df1)
#&gt; &#39;data.frame&#39;:    3 obs. of  3 variables:
#&gt;  $ face : chr  &quot;ace&quot; &quot;two&quot; &quot;six&quot;
#&gt;  $ suit : chr  &quot;clubs&quot; &quot;clubs&quot; &quot;clubs&quot;
#&gt;  $ value: num  1 2 3</code></pre>
<p>You can use <code>View</code> to See the full dataframe. And you can use <code>head</code> to list the first few lines(default = 6) of the dataframe.</p>
<pre class="r"><code># View(df1)
head(df1, n=2L)
#&gt;   face  suit value
#&gt; 1  ace clubs     1
#&gt; 2  two clubs     2</code></pre>
<div id="tibbles" class="section level3">
<h3>3.9.1 Tibbles</h3>
<p>Tibbles are augmented lists: they have class “tbl_df” + “tbl” + “data.frame”, and <code>names</code> (column) and <code>row.names</code> attributes:</p>
<pre class="r"><code>tb &lt;- tibble::tibble(x = 1:5, y = 5:1)
tb
#&gt; # A tibble: 5 x 2
#&gt;       x     y
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     5
#&gt; 2     2     4
#&gt; 3     3     3
#&gt; 4     4     2
#&gt; 5     5     1
typeof(tb)
#&gt; [1] &quot;list&quot;
attributes(tb)
#&gt; $names
#&gt; [1] &quot;x&quot; &quot;y&quot;
#&gt; 
#&gt; $row.names
#&gt; [1] 1 2 3 4 5
#&gt; 
#&gt; $class
#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</code></pre>
<p>The difference between a tibble and a list is that all the elements of a data frame must be vectors with the same length. All functions that work with tibbles enforce this constraint.</p>
<p>Traditional data.frames have a very similar structure:</p>
<pre class="r"><code>df2 &lt;- data.frame(x = 1:5, y = 5:1)
df2
#&gt;   x y
#&gt; 1 1 5
#&gt; 2 2 4
#&gt; 3 3 3
#&gt; 4 4 2
#&gt; 5 5 1
typeof(df2)
#&gt; [1] &quot;list&quot;
attributes(df2)
#&gt; $names
#&gt; [1] &quot;x&quot; &quot;y&quot;
#&gt; 
#&gt; $class
#&gt; [1] &quot;data.frame&quot;
#&gt; 
#&gt; $row.names
#&gt; [1] 1 2 3 4 5</code></pre>
<p>The main difference is the class. The class of tibble includes “data.frame” which means tibbles inherit the regular data frame behaviour by default.</p>
</div>
</div>
</div>
<div id="operators" class="section level1">
<h1>4 Operators</h1>
<p>There are four main categories of Operators in R programming language.</p>
<ol style="list-style-type: decimal">
<li><p>Assignment Operators</p></li>
<li><p>Arithmetic Operators</p></li>
<li><p>Relational Operators</p></li>
<li><p>Logical Operators</p></li>
</ol>
<div id="assignment-operators" class="section level2">
<h2>4.1 Assignment Operators</h2>
<p>Assignment Operators are those that help in assigning a value to the variable.</p>
<pre class="r"><code>a = 2
a
#&gt; [1] 2
a &lt;- TRUE
a
#&gt; [1] TRUE
454 -&gt; a
a
#&gt; [1] 454
a &lt;&lt;- 2.9
a
#&gt; [1] 2.9
c(6, 8, 9) -&gt; a
a
#&gt; [1] 6 8 9</code></pre>
</div>
<div id="arithmetic-operators" class="section level2">
<h2>4.2 Arithmetic Operators</h2>
<p>Arithmetic Operators are used to accomplish arithmetic operations.</p>
<div class="cols2">
<div>
<p>Example for scalars:</p>
<pre class="r"><code>a &lt;- 7.5
b &lt;- 2

print ( a+b ) #addition
#&gt; [1] 9.5
print ( a-b ) #subtraction
#&gt; [1] 5.5
print ( a*b ) #multiplication
#&gt; [1] 15
print ( a/b ) #Division
#&gt; [1] 3.75
print ( a%%b ) #Reminder
#&gt; [1] 1.5
print ( a%/%b ) #Quotient
#&gt; [1] 3
print ( a^b ) #Power of
#&gt; [1] 56.25</code></pre>
</div>
<div>
<p>Example for vectors:</p>
<pre class="r"><code>a &lt;- c(8, 9, 6)
b &lt;- c(2, 4, 5)

print ( a+b ) #addition
#&gt; [1] 10 13 11
print ( a-b ) #subtraction
#&gt; [1] 6 5 1
print ( a*b ) #multiplication
#&gt; [1] 16 36 30
print ( a/b ) #Division
#&gt; [1] 4.00 2.25 1.20
print ( a%%b ) #Reminder
#&gt; [1] 0 1 1
print ( a%/%b ) #Quotient
#&gt; [1] 4 2 1
print ( a^b ) #Power of
#&gt; [1]   64 6561 7776</code></pre>
</div>
</div>
<p>You can do inner multiplication with the <code>%*%</code> operator and outer multiplication with the <code>%o%</code> operator:</p>
<pre class="r"><code>die &lt;- c(1:6)
die %*% die
#&gt;      [,1]
#&gt; [1,]   91
die %o% die
#&gt;      [,1] [,2] [,3] [,4] [,5] [,6]
#&gt; [1,]    1    2    3    4    5    6
#&gt; [2,]    2    4    6    8   10   12
#&gt; [3,]    3    6    9   12   15   18
#&gt; [4,]    4    8   12   16   20   24
#&gt; [5,]    5   10   15   20   25   30
#&gt; [6,]    6   12   18   24   30   36</code></pre>
</div>
<div id="relational-operators" class="section level2">
<h2>4.3 Relational Operators</h2>
<p>Relational Operators are those that find out relation between the two operands provided to them. The output is boolean (TRUE or FALSE) for all of the Relational Operators in R programming language.</p>
<table>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Syntax</th>
<th align="left">Tests</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&gt;</code></td>
<td align="left"><code>a &gt; b</code></td>
<td align="left">Is a greater than b?</td>
</tr>
<tr class="even">
<td align="left"><code>&gt;=</code></td>
<td align="left"><code>a &gt;= b</code></td>
<td align="left">Is a greater than or equal to b?</td>
</tr>
<tr class="odd">
<td align="left"><code>&lt;</code></td>
<td align="left"><code>a &lt; b</code></td>
<td align="left">Is a less than b?</td>
</tr>
<tr class="even">
<td align="left"><code>&lt;=</code></td>
<td align="left"><code>a &lt;= b</code></td>
<td align="left">Is a less than or equal to b?</td>
</tr>
<tr class="odd">
<td align="left"><code>==</code></td>
<td align="left"><code>a == b</code></td>
<td align="left">Is a equal to b?</td>
</tr>
<tr class="even">
<td align="left"><code>!=</code></td>
<td align="left"><code>a != b</code></td>
<td align="left">Is a not equal to b?</td>
</tr>
<tr class="odd">
<td align="left"><code>%in%</code></td>
<td align="left"><code>a %in% c(a, b, c)</code></td>
<td align="left">Is a in the group c(a, b, c)?</td>
</tr>
</tbody>
</table>
<div class="cols2">
<div>
<p>Example for scalars:</p>
<pre class="r"><code>a &lt;- 7.5
b &lt;- 2

print ( a&lt;b ) # less than
#&gt; [1] FALSE
print ( a&gt;b ) # greater than
#&gt; [1] TRUE
print ( a==b ) # equal to
#&gt; [1] FALSE
print ( a&lt;=b ) # less than or equal to
#&gt; [1] FALSE
print ( a&gt;=b ) # greater than or equal to
#&gt; [1] TRUE
print ( a!=b ) # not equal to
#&gt; [1] TRUE</code></pre>
</div>
<div>
<p>Example for vectors:</p>
<pre class="r"><code>a &lt;- c(7.5, 3, 5)
b &lt;- c(2, 7, 0)

print ( a&lt;b ) # less than
#&gt; [1] FALSE  TRUE FALSE
print ( a&gt;b ) # greater than
#&gt; [1]  TRUE FALSE  TRUE
print ( a==b ) # equal to
#&gt; [1] FALSE FALSE FALSE
print ( a&lt;=b ) # less than or equal to
#&gt; [1] FALSE  TRUE FALSE
print ( a&gt;=b ) # greater than or equal to
#&gt; [1]  TRUE FALSE  TRUE
print ( a!=b ) # not equal to
#&gt; [1] TRUE TRUE TRUE</code></pre>
</div>
</div>
<p><code>%in%</code> is the only operator that does not do normal element-wise execution. <code>%in%</code> tests whether the value(s) on the left side are in the vector on the right side. If you provide a vector on the left side, <code>%in%</code> will <em>not</em> pair up the values on the left with the values on the right and then do element-wise tests. Instead, <code>%in%</code> will independently test whether each value on the left is <em>somewhere</em> in the vector on the right:</p>
<pre class="r"><code>1 %in% c(3, 4, 5)
#&gt; [1] FALSE
c(1, 2) %in% c(3, 4, 5)
#&gt; [1] FALSE FALSE
c(1, 2, 3) %in% c(3, 4, 5)
#&gt; [1] FALSE FALSE  TRUE
c(1, 2, 3, 4) %in% c(3, 4, 5)
#&gt; [1] FALSE FALSE  TRUE  TRUE</code></pre>
<p>Notice that you test for equality with a double equals sign, <code>==</code>, and not a single equals sign, <code>=</code>, which is another way to write <code>&lt;-</code>.</p>
</div>
<div id="logical-operators" class="section level2">
<h2>4.4 Logical Operators</h2>
<p>Logical Operators in R programming language work only for the basic data types logical, numeric and complex and vectors of these basic data types.</p>
<table>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Syntax</th>
<th align="left">Tests</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&amp;</code></td>
<td align="left"><code>cond1 &amp; cond2</code></td>
<td align="left">Are both <code>cond1</code> and <code>cond2</code> true?</td>
</tr>
<tr class="even">
<td align="left"><code>|</code></td>
<td align="left"><code>cond1 | cond2</code></td>
<td align="left">Is one or more of <code>cond1</code> and <code>cond2</code> true?</td>
</tr>
<tr class="odd">
<td align="left"><code>xor</code></td>
<td align="left"><code>xor(cond1, cond2)</code></td>
<td align="left">Is exactly one of <code>cond1</code> and <code>cond2</code> true?</td>
</tr>
<tr class="even">
<td align="left"><code>!</code></td>
<td align="left"><code>!cond1</code></td>
<td align="left">Is <code>cond1</code> false? (e.g., <code>!</code> flips the results of a logical test)</td>
</tr>
<tr class="odd">
<td align="left"><code>any</code></td>
<td align="left"><code>any(cond1, cond2, cond3, ...)</code></td>
<td align="left">Are any of the conditions true?</td>
</tr>
<tr class="even">
<td align="left"><code>all</code></td>
<td align="left"><code>all(cond1, cond2, cond3, ...)</code></td>
<td align="left">Are all of the conditions true?</td>
</tr>
</tbody>
</table>
<div class="cols2">
<div>
<p>Example for basic logical elements:</p>
<pre class="r"><code>a &lt;- 0 # logical FALSE
b &lt;- 2 # logical TRUE

print ( a &amp; b ) # logical AND element wise
#&gt; [1] FALSE
print ( a | b ) # logical OR element wise
#&gt; [1] TRUE
print ( !a ) # logical NOT element wise
#&gt; [1] TRUE
print ( a &amp;&amp; b ) # logical AND consolidated for all elements
#&gt; [1] FALSE
print ( a || b ) # logical OR consolidated for all elements
#&gt; [1] TRUE</code></pre>
</div>
<div>
<p>Example for boolean vectors:</p>
<pre class="r"><code>a &lt;- c(TRUE, TRUE, FALSE, FALSE)
b &lt;- c(TRUE, FALSE, TRUE, FALSE)

print ( a &amp; b ) # logical AND element wise
#&gt; [1]  TRUE FALSE FALSE FALSE
print ( a | b ) # logical OR element wise
#&gt; [1]  TRUE  TRUE  TRUE FALSE
print ( !a ) # logical NOT element wise
#&gt; [1] FALSE FALSE  TRUE  TRUE
print ( a &amp;&amp; b ) # logical AND consolidated for all elements
#&gt; [1] TRUE
print ( a || b ) # logical OR consolidated for all elements
#&gt; [1] TRUE</code></pre>
</div>
</div>
<p>You can use <code>||</code> (or) and <code>&amp;&amp;</code> (and) to combine multiple logical expressions. These operators are “short-circuiting”: as soon as <code>||</code> sees the first <code>TRUE</code> it returns <code>TRUE</code> without computing anything else. As soon as <code>&amp;&amp;</code> sees the first <code>FALSE</code> it returns <code>FALSE</code>. You should never use <code>|</code> or <code>&amp;</code> in an <code>if</code> statement: these are vectorised operations that apply to multiple values. If you do have a logical vector, you can use <code>any()</code> or <code>all()</code> to collapse it to a single value.</p>
<pre class="r"><code>a &lt;- c(TRUE, TRUE, FALSE, FALSE)
b &lt;- c(TRUE, FALSE, TRUE, FALSE)

xor(a,b)
#&gt; [1] FALSE  TRUE  TRUE FALSE
any(a,b)
#&gt; [1] TRUE
all(a,b)
#&gt; [1] FALSE</code></pre>
</div>
<div id="missing-information" class="section level2">
<h2>4.5 Missing Information</h2>
<p>Missing information problems happen frequently in data science. Usually, they are more straightforward: you don’t know a value because the measurement was lost, corrupted, or never taken to begin with. R has a way to help you manage these missing values.</p>
<p>The <code>NA</code> character is a special symbol in R. It stands for “not available” and can be used as a placeholder for missing information. R will treat NA exactly as you should want missing information treated.</p>
<pre class="r"><code>1 + NA
#&gt; [1] NA
NA == 1
#&gt; [1] NA
NA != 1
#&gt; [1] NA
NA == NA
#&gt; [1] NA
!NA
#&gt; [1] NA
NA %in% c(TRUE, 0, FALSE)
#&gt; [1] FALSE
NA %in% c(TRUE, NA, FALSE)
#&gt; [1] TRUE
NA &amp; TRUE
#&gt; [1] NA
NA | TRUE
#&gt; [1] TRUE
NA &amp; FALSE
#&gt; [1] FALSE
NA | FALSE
#&gt; [1] NA</code></pre>
<div id="na.rm" class="section level3">
<h3>4.5.1 na.rm</h3>
<p>Missing values can help you work around holes in your data sets, but they can also create some frustrating problems.</p>
<pre class="r"><code>c(NA, 1:50)
#&gt;  [1] NA  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
#&gt; [26] 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
#&gt; [51] 50
mean(c(NA, 1:50))
#&gt; [1] NA</code></pre>
<p>Most R functions come with the optional argument, <code>na.rm</code>, which stands for <code>NA</code> remove. R will ignore <code>NA</code>s when it evaluates a function if you add the argument <code>na.rm = TRUE</code>:</p>
<pre class="r"><code>mean(c(NA, 1:50), na.rm = TRUE)
#&gt; [1] 25.5</code></pre>
</div>
<div id="is.na" class="section level3">
<h3>4.5.2 is.na</h3>
<p>On occasion, you may want to identify the <code>NA</code>s in your data set with a logical test, but that too creates a problem.</p>
<pre class="r"><code>NA == NA
#&gt; [1] NA
c(1, 2, 3, NA) == NA
#&gt; [1] NA NA NA NA</code></pre>
<p>R supplies a special function that can test whether a value is an <code>NA</code>. The function is sensibly named <code>is.na</code>:</p>
<pre class="r"><code>is.na(NA)
#&gt; [1] TRUE
vec &lt;- c(1, 2, 3, NA)
is.na(vec)
#&gt; [1] FALSE FALSE FALSE  TRUE</code></pre>
</div>
</div>
</div>
<div id="conditional-statement" class="section level1">
<h1>5 Conditional Statement</h1>
<p>An <code>if</code> statement allows you to conditionally execute code. It looks like this:</p>
<pre class="r"><code>if (condition) {
  # code executed when condition is TRUE
} else {
  # code executed when condition is FALSE
}</code></pre>
<div id="if-statement" class="section level2">
<h2>5.1 If Statement</h2>
<p>The If statement helps you in evaluating a single expression as part of the flow. To perform this evaluation, you just need to write the If keyword followed by the expression to be evaluated.It looks like this:</p>
<pre class="r"><code>num1 &lt;- 10
num2 &lt;- 20

if(num1 &lt;= num2){
  print(&quot;Num1 is less or equal to Num2&quot;)
}
#&gt; [1] &quot;Num1 is less or equal to Num2&quot;</code></pre>
<p>The <code>condition</code> must evaluate to either <code>TRUE</code> or <code>FALSE</code>. If it’s a vector, you’ll get a warning message; if it’s an <code>NA</code>, you’ll get an error. Watch out for these messages in your own code:</p>
<pre class="r"><code>if (c(TRUE, FALSE)) {}
#&gt; Warning in if (c(TRUE, FALSE)) {: the condition has length &gt; 1 and only the
#&gt; first element will be used
#&gt; NULL
if (NA) {}
#&gt; Error in if (NA) {: missing value where TRUE/FALSE needed</code></pre>
</div>
<div id="else-if-statement" class="section level2">
<h2>5.2 Else If Statement:</h2>
<p>The Else if statement helps you in extending branches to the flow created by the If statement and give you the opportunity to evaluate multiple conditions by creating new branches of flow.</p>
<pre class="r"><code>Num1 &lt;-  10
Num2 &lt;-  20

if (Num1 &lt; Num2) { 
  print(&quot;Num1 is lesser than Num2&quot;) 
} else if( Num1 &gt; Num2) {
  print(&quot;Num2 is lesser than Num1&quot;) 
} else {
  print(&quot;Num1 and Num2 are Equal&quot;)
}
#&gt; [1] &quot;Num1 is lesser than Num2&quot;</code></pre>
<pre class="r"><code>x &lt;- 2

if (x &gt; 2) {
  print(&quot;x is greater than 2&quot;)
} else if (x == 2) {
  print(&quot;x is equal to 2&quot;)
} else {
  print(&quot;x is not greater than 2&quot;)
}
#&gt; [1] &quot;x is equal to 2&quot;</code></pre>
</div>
<div id="else-statement" class="section level2">
<h2>5.3 Else Statement:</h2>
<p>The else statement is used when all the other expressions are checked and found invalid. This will be the last statement that gets executed as part of the If – Else if branch.</p>
<pre class="r"><code>x &lt;- -5

if (x &gt; 0) {
  print(&quot;Non-negative number&quot;)
} else {
  print(&quot;Negative number&quot;)
}
#&gt; [1] &quot;Negative number&quot;</code></pre>
</div>
<div id="ifelse" class="section level2">
<h2>5.4 ifelse</h2>
<p><code>ifelse()</code> has three arguments. The first argument <code>test</code> should be a logical vector. The result will contain the value of the second argument, <code>yes</code>, when <code>test</code> is <code>TRUE</code>, and the value of the third argument, <code>no</code>, when it is false.</p>
<pre class="r"><code>x &lt;- c(-2, 0, 1)
y &lt;- ifelse(x &gt;= 0, 1, 0); print(y)
#&gt; [1] 0 1 1

ifelse((1:6) &gt;= 3, 1:2, c(-1,-2))
#&gt; [1] -1 -2  1  2  1  2</code></pre>
</div>
</div>
<div id="loops" class="section level1">
<h1>6 Loops</h1>
<p>Loops are R’s method for repeating a task, which makes them a useful tool for programming simulations. A loop statement allows us to execute a statement or group of statements multiple times. There are mainly 3 types of loops in R:</p>
<div id="repeat-loop" class="section level2">
<h2>6.1 Repeat Loop</h2>
<p>It repeats a statement or group of statements while a given condition is TRUE. Repeat loop is the best example of an exit controlled loop where the code is first executed and then the condition is checked to determine if the control should be inside the loop or exit from it.</p>
<p>A block of statements are repeated forever. A breaking condition has to be provided inside the repeat block to come out of the loop.</p>
<p>It looks like this:</p>
<pre class="r"><code>repeat {   
  statements  
  if (stop_condition) {    
    break   
  } 
}</code></pre>
<pre class="r"><code>a &lt;-  1

repeat {
  # starting of repeat statements block
  print(a)
  a &lt;- a + 1
  # ending of repeat statements block
  if(a &gt; 5) { # breaking condition
    break
  }
}
#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
#&gt; [1] 4
#&gt; [1] 5</code></pre>
</div>
<div id="while-loop" class="section level2">
<h2>6.2 While Loop</h2>
<p>It helps to repeats a statement or group of statements while a given condition is TRUE. While loop, when compared to the repeat loop is slightly different, it is an example of an entry controlled loop where the condition is first checked and only if the condition is found to be true does the control be delivered inside the loop to execute the code.</p>
<p>A block of statements are executed repeatedly in a loop till the condition provided to while statement returns TRUE.</p>
<p>It looks like this:</p>
<pre class="r"><code>while (condition) {  
  statements
}</code></pre>
<pre class="r"><code>a &lt;- 1

while(a &lt;= 5) {
  print(a)
  a &lt;- a + 1
}
#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
#&gt; [1] 4
#&gt; [1] 5</code></pre>
</div>
<div id="for-loop" class="section level2">
<h2>6.3 For Loop</h2>
<p>It is used to repeats a statement or group of for a fixed number of times. Unlike repeat and while loop, the for loop is used in situations where we are aware of the number of times the code needs to executed beforehand. It is similar to the while loop where the condition is first checked and then only does the code written inside get executed.</p>
<p>A block of statements are executed for each of the items in the list provided to the for loop.</p>
<p>It looks like this:</p>
<pre class="r"><code>for (x in vector) {
  statements
}</code></pre>
<pre class="r"><code>a &lt;- c(1:5)

for(i in a) {
  print(i)
}
#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
#&gt; [1] 4
#&gt; [1] 5</code></pre>
<p>To save output from a <code>for</code> loop, you must write the loop so that it saves its own output as it runs. You can do this by creating an empty vector or list before you run the <code>for</code> loop. Then use the <code>for</code> loop to fill up the vector or list. When the <code>for</code> loop is finished, you’ll be able to access the vector or list, which will now have all of your results.</p>
<pre class="r"><code>a &lt;- c(1:5)
output &lt;- vector(length = length(a))

for(i in seq_along(a)) {
  output[i] &lt;- a[i] * 2
}
output
#&gt; [1]  2  4  6  8 10</code></pre>
<p>You might not have seen <code>seq_along()</code> before.It’s a safe version of the familiar <code>1:length(l)</code>, with an important difference: if you have a zero-length vector, <code>seq_along()</code> does the right thing:</p>
<pre class="r"><code>y &lt;- vector(&quot;double&quot;, 0)
seq_along(y)
#&gt; integer(0)
1:length(y)
#&gt; [1] 1 0</code></pre>
<p>You probably won’t create a zero-length vector deliberately, but it’s easy to create them accidentally. If you use <code>1:length(x)</code> instead of <code>seq_along(x)</code>, you’re likely to get a confusing error message.</p>
</div>
</div>
<div id="functions" class="section level1">
<h1>7 Functions</h1>
<p>R comes with many functions that you can use to do sophisticated tasks like random sampling. Using a function is pretty simple. Just write the name of the function and then the data you want the function to operate on in parentheses:</p>
<pre class="r"><code>round(3.1415)
#&gt; [1] 3
factorial(3)
#&gt; [1] 6
cumsum(1:5)
#&gt; [1]  1  3  6 10 15
cumprod(1:5)
#&gt; [1]   1   2   6  24 120</code></pre>
<p>The data that you pass into the function is called the function’s <em>argument</em>. The argument can be raw data, an R object, or even the results of another R function. And R will work from the innermost function to the outermost.</p>
<pre class="r"><code>die &lt;- c(1:6)
mean(die)
#&gt; [1] 3.5
round(mean(die))
#&gt; [1] 4
sample(die, size = 3)
#&gt; [1] 5 3 4
sample(die, size = 3, replace = TRUE)
#&gt; [1] 3 1 2</code></pre>
<p>If you’re not sure which names to use with a function, you can look up the function’s arguments with <code>args</code>. To do this, place the name of the function in the parentheses behind <code>args</code>.</p>
<pre class="r"><code>args(round)
#&gt; function (x, digits = 0) 
#&gt; NULL
args(sample)
#&gt; function (x, size, replace = FALSE, prob = NULL) 
#&gt; NULL</code></pre>
<div id="writing-your-own-functions" class="section level2">
<h2>7.1 Writing Your Own Functions</h2>
<p>Every function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the <code>function</code> function. To do this, call <code>function()</code> and follow it with a pair of braces, <code>{}</code>:</p>
<pre class="r"><code>my_function &lt;- function(arguments) {
  # code
}</code></pre>
<pre class="r"><code>roll &lt;- function() {
  die &lt;- 1:6
  dice &lt;- sample(die, size = 2, replace = TRUE)
  sum(dice)
}</code></pre>
<p>You can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name <em>without</em> the parentheses, R will show you the code that is stored inside the function. If you type in the name <em>with</em> the parentheses, R will run that code:</p>
<pre class="r"><code>roll
#&gt; function() {
#&gt;   die &lt;- 1:6
#&gt;   dice &lt;- sample(die, size = 2, replace = TRUE)
#&gt;   sum(dice)
#&gt; }
roll()
#&gt; [1] 7</code></pre>
<p>The code that you place inside your function is known as the <em>body</em> of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value.</p>
<p>Here’s some code that would display a result:</p>
<pre class="r"><code>dice
1 + 1
sqrt(2)</code></pre>
<p>And here’s some code that would not:</p>
<pre class="r"><code>dice &lt;- sample(die, size = 2, replace = TRUE)
two &lt;- 1 + 1
a &lt;- sqrt(2)</code></pre>
<p>These lines of code do not return a value to the command line; they save a value to an object.</p>
<p>You can supply <code>bones</code> when you call <code>roll2</code> if you make <code>bones</code> an argument of the function. To do this, put the name <code>bones</code> in the parentheses that follow <code>function</code> when you define <code>roll2</code>:</p>
<pre class="r"><code>roll2 &lt;- function(bones) {
  dice &lt;- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}
roll2(bones = 1:4)
#&gt; [1] 6
roll2(1:6)
#&gt; [1] 3</code></pre>
<p>Notice that <code>roll2</code> will still give an error if you do not supply a value for the <code>bones</code> argument when you call <code>roll2</code>:</p>
<pre class="r"><code>roll2()
#&gt; Error in sample(bones, size = 2, replace = TRUE): argument &quot;bones&quot; is missing, with no default</code></pre>
<p>You can prevent this error by giving the <code>bones</code> argument a default value. To do this, set <code>bones</code> equal to a value when you define <code>roll2</code>:</p>
<pre class="r"><code>roll2 &lt;- function(bones = 1:6) {
  dice &lt;- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}</code></pre>
<p>Now you can supply a new value for <code>bones</code> if you like, and <code>roll2</code> will use the default if you do not:</p>
<pre class="r"><code>roll2()
#&gt; [1] 6
roll2(1:20)
#&gt; [1] 13</code></pre>
<p>You can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow <code>function</code>. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).</p>
</div>
</div>
<div id="reference" class="section level1">
<h1>Reference</h1>
<p><a href="https://rstudio-education.github.io/hopr/" target="_blank">Hands-On Programming with R</a></p>
<p><a href="https://r4ds.had.co.nz/index.html" target="_blank">R for Data Science</a></p>
<p><a href="https://github.com/suneelpatel/R-for-Beginners" target="_blank">R for Beginners</a></p>
<p><a href="https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html" target="_blank">R语言教程</a></p>
<p><a href="https://github.com/rstudio/cheatsheets/blob/master/base-r.pdf" target="_blank">Cheatsheet Base-R</a></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
